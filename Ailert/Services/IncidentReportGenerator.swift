// IncidentReportGenerator.swift
// Generates incident reports in plain English and JSON formats

import Foundation

class IncidentReportGenerator {
    
    // MARK: - Report Generation
    
    func generateReport(for incident: Incident) -> IncidentReport {
        let plainText = generatePlainTextReport(for: incident)
        let json = generateJSONReport(for: incident)
        
        return IncidentReport(
            incidentId: incident.id,
            generatedAt: Date(),
            plainTextReport: plainText,
            jsonReport: json
        )
    }
    
    // MARK: - Plain Text Report
    
    private func generatePlainTextReport(for incident: Incident) -> String {
        var report = """
        ═══════════════════════════════════════════════════════════════
        AILERT INCIDENT REPORT
        ═══════════════════════════════════════════════════════════════
        
        """
        
        // Header
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .long
        dateFormatter.timeStyle = .medium
        
        report += "Incident ID: \(incident.id.uuidString)\n"
        report += "Status: \(incident.status.rawValue.capitalized)\n"
        report += "Classification: \(incident.classification.displayName)\n"
        if incident.confidence > 0 {
            report += "Confidence: \(Int(incident.confidence * 100))%\n"
        }
        report += "\n"
        
        // Timeline
        report += "── TIMELINE ──────────────────────────────────────────────────\n\n"
        report += "Started: \(dateFormatter.string(from: incident.sessionStart))\n"
        if let end = incident.sessionEnd {
            report += "Ended: \(dateFormatter.string(from: end))\n"
            let duration = end.timeIntervalSince(incident.sessionStart)
            report += "Duration: \(formatDuration(duration))\n"
        }
        report += "\n"
        
        // Events
        if !incident.events.isEmpty {
            report += "── EVENTS ────────────────────────────────────────────────────\n\n"
            
            let timeFormatter = DateFormatter()
            timeFormatter.timeStyle = .medium
            
            for event in incident.events {
                report += "[\(timeFormatter.string(from: event.timestamp))] \(event.description)\n"
            }
            report += "\n"
        }
        
        // Location
        if !incident.locationSnapshots.isEmpty {
            report += "── LOCATION ──────────────────────────────────────────────────\n\n"
            
            if let firstLocation = incident.locationSnapshots.first {
                report += "First Location: \(firstLocation.latitude), \(firstLocation.longitude)\n"
                report += "Maps Link: https://maps.apple.com/?ll=\(firstLocation.latitude),\(firstLocation.longitude)\n"
            }
            
            if let lastLocation = incident.locationSnapshots.last,
               incident.locationSnapshots.count > 1 {
                report += "Last Location: \(lastLocation.latitude), \(lastLocation.longitude)\n"
                report += "Maps Link: https://maps.apple.com/?ll=\(lastLocation.latitude),\(lastLocation.longitude)\n"
            }
            
            report += "Total Location Points: \(incident.locationSnapshots.count)\n"
            report += "\n"
        }
        
        // Media
        if !incident.mediaCaptures.isEmpty {
            report += "── MEDIA CAPTURED ────────────────────────────────────────────\n\n"
            
            let videos = incident.mediaCaptures.filter { $0.type == .video }
            let photos = incident.mediaCaptures.filter { $0.type == .photo }
            let audio = incident.mediaCaptures.filter { $0.type == .audio }
            
            if !videos.isEmpty {
                report += "Videos: \(videos.count)\n"
                for video in videos {
                    if let duration = video.duration {
                        report += "  - \(formatDuration(duration))\n"
                    }
                }
            }
            
            if !photos.isEmpty {
                report += "Photos: \(photos.count)\n"
            }
            
            if !audio.isEmpty {
                report += "Audio Recordings: \(audio.count)\n"
            }
            
            report += "\n"
        }
        
        // Escalation
        report += "── ESCALATION ────────────────────────────────────────────────\n\n"
        report += "Level Reached: \(incident.escalationLevel.displayName)\n"
        report += "\n"
        
        // Footer
        report += "═══════════════════════════════════════════════════════════════\n"
        report += "Generated by Ailert Emergency Assistant\n"
        report += "Report Generated: \(dateFormatter.string(from: Date()))\n"
        report += "═══════════════════════════════════════════════════════════════\n"
        
        return report
    }
    
    // MARK: - JSON Report
    
    private func generateJSONReport(for incident: Incident) -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        guard let data = try? encoder.encode(incident),
              let json = String(data: data, encoding: .utf8) else {
            return "{\"error\": \"Failed to encode incident\"}"
        }
        
        return json
    }
    
    // MARK: - Helpers
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
    
    // MARK: - Save Report
    
    func saveReport(_ report: IncidentReport) -> URL? {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let reportsPath = documentsPath.appendingPathComponent("IncidentReports", isDirectory: true)
        
        try? FileManager.default.createDirectory(at: reportsPath, withIntermediateDirectories: true)
        
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let filename = "report_\(formatter.string(from: report.generatedAt)).txt"
        
        let fileURL = reportsPath.appendingPathComponent(filename)
        
        do {
            try report.plainTextReport.write(to: fileURL, atomically: true, encoding: .utf8)
            return fileURL
        } catch {
            print("Failed to save report: \(error)")
            return nil
        }
    }
}

// MARK: - Report Model

struct IncidentReport {
    let incidentId: UUID
    let generatedAt: Date
    let plainTextReport: String
    let jsonReport: String
}
